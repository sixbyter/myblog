## 26 Dec 15 Unix 关于文件锁

-  作者: [sixbyte](http://sixbyte.me/)
-  邮箱: liu.sixbyte@gmail.com
-  禁止转载


最近在整理 `PHP` 的函数, 因为很多扩展的函数都只是了解而没有去真正的推敲过. 在看到 `flock()` 的时候, 以为文件锁和数据库的锁是同一回事, 形成了一些误区. 其实文件锁和数据库的锁有一些不同的地方. 然后, 查找了关于文件锁的相关资料, 现在总结一下.

主要参考资料: [Linux 2.6 中的文件锁 IBM developerWorks](https://www.ibm.com/developerworks/cn/linux/l-cn-filelock/)

### 文件锁

在多任务操作系统环境中，如果一个进程尝试对正在被其他进程读取的文件进行写操作，可能会导致正在进行读操作的进程读取到一些被破坏或者不完整的数据；如果两个进程并发对同一个文件进行写操作，可能会导致该文件遭到破坏。因此，为了避免发生这种问题，必须要采用某种机制来解决多个进程并发访问同一个文件时所面临的同步问题，由此而产生了文件加锁方面的技术。

Linux 支持的文件锁技术主要包括劝告锁（advisory lock）和强制锁（mandatory lock）这两种。此外，`Linux` 中还引入了两种强制锁的变种形式：共享模式强制锁（share-mode mandatory lock）和租借锁（lease）。 这些类型的锁同时使用共享锁和排他锁(又称为读锁和写锁).

也就是说, 我们平时听得最多的共享锁和排他锁其实在文件锁的概念中, 他们的上级还有劝告锁和强制锁这两种. 然后强制锁并不是所有系统都支持. `Unix` 支持劝告锁, 并不支持强制锁, 基于 `Unix` 的 `OS X` 也一样. 也就是说, 在 `Unix` 系统中, 我们只能使用 `Unix` 的共享锁和排他锁机制. `Linux` 也是在 `System V Release 3` 后引入.

### 共享锁和排他锁

共享锁和排他锁, 这两个的概念在网上是找不到单独的定义, 也就是说他们是一对存在的. 利用共享锁和排他锁的技术, 可以解决多个进程并发访问同一个文件时所面临的同步问题(应该说为了解决这个问题, 人类想出了这个机制). 然后也正是为了解决了这个问题, 他们又被叫做读锁和写锁, 其实我一点都不同意!!! 这种叫法完全容易导致理解错误.他们的机制如下:

一个文件, 进程想要获得他的共享锁和排他锁, 需要根据情况而定.

| 当前加上的锁 | 共享锁 | 排他锁 |
| ---------- | ----- | ---- |
| 无         | 是    | 是    |
| 共享锁      | 是    | 否    |
| 排他锁      | 否    | 否    |

也就是说:
- 文件没有被上锁, 进程可以获得共享锁和排他锁
- 文件被上共享锁, 进程可以获得共享锁, 但不能获得排他锁
- 文件被上排他锁, 进程不能获得共享锁和排他锁

共享锁和排他锁 让我解释, 就是并发的进程之间的协作而给文件的一个状态. 而利用这个状态, 我们可以实现读写的同步性. 并不是因为加了读锁, 其他进程就不能写, 加了写锁, 其他进程就不能读和写(让我再吐槽一下, 因为我因此进入了误区%>_<%).

**跟强制锁不同, 共享锁和排他锁 是要进程之间互相遵守 "游戏规则" 才有意义**

当 `flock_a.php` 程序获得文件 `temp.txt` 的排他锁时, 其他进程/线程依然能对 `temp.txt` 进行读写操作.

`flock_a.php` 程序
```
$file = "temp.txt";
$fp   = fopen($file, 'w');
if (flock($fp, LOCK_EX)) {
    fwrite($fp, "abc");
    sleep(10);
    fwrite($fp, "123");
    flock($fp, LOCK_UN);
}
fclose($fp);
```

`flock_b.php` 程序 没有遵守 "游戏规则"
```
$file = "temp.txt";
$fp   = fopen($file, 'r+');
rewind($fp);
fwrite($fp, "bbbbbbbbbbbbbbbbbb");
echo fread($fp, 100);
fclose($fp);
```
`flock_b.php` 程序 遵守 "游戏规则"
```
$file = "temp.txt";
$fp   = fopen($file, 'r+');
if (flock($fp, LOCK_SH)) {
    rewind($fp);
    fwrite($fp, "bbbbbbbbbbbbbbbbbb");
    echo fread($fp, 100);
    flock($fp, LOCK_UN);
} else {
    echo "Lock file failed...\n";
}
fclose($fp);
```

也就是说你并不能阻止第三方程序对文件的操作. Linux 的强制锁解决了这个问题哦~~

文件的读写同步问题有 16 种情况:

| #  | 被读的时候读 | 被读的时候写 |  被写的时候读 |  被写的时候写 |
| -- | --------- | ---------  | --------- | ---------  |
|  1 | 1    | 1   |  1   |   1     |
|  2 | 1    | 1   |  1   |   0     |
|  3 | 1    | 1   |  0   |   0     |
|  4 | 1    | 1   |  0   |   1     |
|  5 | 1    | 0   |  1   |   1     |
|  6 | 1    | 0   |  1   |   0     |
|  7 | 1    | 0   |  0   |   0     |
|  8 | 1    | 0   |  0   |   1     |
|  9 | 0    | 1   |  1   |   1     |
| 10 | 0    | 1   |  1   |   0     |
| 11 | 0    | 1   |  0   |   0     |
| 12 | 0    | 1   |  0   |   1     |
| 13 | 0    | 0   |  1   |   1     |
| 14 | 0    | 0   |  1   |   0     |
| 15 | 0    | 0   |  0   |   0     |
| 16 | 0    | 0   |  0   |   1     |


第1种情况, 不需要用到锁机制. 很简单, 随便写随便读

第2种情况, 读的程序不需要用到锁功能, 写的程序要用排他锁

第3种情况, 无法用同一个读写程序来实现, 假设A1在读, A2再去读和写. A1在写, A2再去读和写等. A1读的时候不用锁, 写的时候用排他锁, A2读的时候用排他锁/共享锁. ok~~这种情况会有什么问题?!??! 你试想, 当A1在读或者写的时候, 进来一个A1程序对文件进行操作, 会发生什么,当A2在读/写的时候, A1进来文件操作是呢??!! 当处于3的状态, 又进来一个A1程序或者A2程序呢??脑补下去是不是一场灾难!??!你说只要A1执行之后再A2执行不就符合了?!?!那根本不需要用到锁机制啊, 按流程执行A1A2就好了. 所以, 我们是不考虑A1,A2的读写不一样的情况的.

第7种情况, 读程序用共享锁, 写程序用排他锁. 目前共享锁和排他锁最常用的情况,保证每一次读都是目前最新的, 每一次写都是没有冲突的.
